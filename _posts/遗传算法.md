---
title: 用matlab实现遗传算法
categories:  技术
description:  HDU数模校赛
avatar: /image/33cat1.jpg
authorAbout: 落叶飘零，又是一个春夏秋冬
photos: https://cdn.jsdelivr.net/gh/che10086/CDN@master/image/cover/img3.jpg
covers:  https://cdn.jsdelivr.net/gh/che10086/CDN@master/image/blog_image/数模/遗传算法/1.jpg
---


## Quick Start

### 遗传算法的定义

遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。

其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的全局寻优能力；采用概率化的寻优方法，不需要确定的规则就能自动获取和指导优化的搜索空间，自适应地调整搜索方向。

遗传算法以一种群体中的所有个体为对象，并利用随机化技术指导对一个被编码的参数空间进行高效搜索。其中，选择、交叉和变异构成了遗传算法的遗传操作；参数编码、初始群体的设定、适应度函数的设计、遗传操作设计、控制参数设定五个要素组成了遗传算法的核心内容。

### 遗传算法执行过程
遗传算法是从代表问题可能潜在的解集的一个种群（population）开始的，而一个种群则由经过基因（gene）编码的一定数目的个体(individual)组成。每个个体实际上是染色体(chromosome)带有特征的实体。

染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形状的外部表现，如黑头发的特征是由染色体中控制这一特征的某种基因组合决定的。因此，在一开始需要实现从表现型到基因型的映射即编码工作。由于仿照基因编码的工作很复杂，我们往往进行简化，如二进制编码。

初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每一代，根据问题域中个体的适应度（fitness）大小选择（selection）个体，并借助于自然遗传学的遗传算子（genetic operators）进行组合交叉（crossover）和变异（mutation），产生出代表新的解集的种群。

这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境，末代种群中的最优个体经过解码（decoding），可以作为问题近似最优解。


### 遗传算法的图解
{% fb_img https://cdn.jsdelivr.net/gh/che10086/CDN@master/image/blog_image/数模/遗传算法/2.webp 1 %}

###相关术语
基因型(genotype)：性状染色体的内部表现；

表现型(phenotype)：染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现；

进化(evolution)：种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。

适应度(fitness)：度量某个物种对于生存环境的适应程度。

选择(selection)：以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程。

复制(reproduction)：细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。

交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交；

变异(mutation)：复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状。

编码(coding)：DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射。

解码(decoding)：基因型到表现型的映射。

个体（individual）：指染色体带有特征的实体；

种群（population）：个体的集合，该集合内个体数称为种群

###举个程序的例子

func5是目标函数，一般套程序只要更改func5中的内容。
限制条件加在func5最后，用一个afa惩罚系数来约束
```[matlab]
%%%%%%%%%%%%%%遗传算法主程序%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear all;%清除所有变量
close all;%清图
clc;%清屏
NP = 50;%种群规模
L= 21+63;%物品件数
Pc = 0.8 ;%交叉率
Pm = 0.05;%变异率
G= 100;%最大遗传代数
afa = 10;%惩罚函数系数
%func5的输入值————————————————
a =-20.8385;
b =-4.1394;
T0=800;
Gy_sum=45;
r=0.075;
k=1440;
%func5的输入值————————————————
f = randi( [0,1],NP,L)%随机获得初始种群

%%%%%%%%%%%%%%%%%%%遗传算法循环%%%%%%%%%%%%%%%%%%%%%
for h = 1:G
    %号%%%%%%%%%%%%%%%%%%适应度计算%%%%%%%%%%%%%%5%%%%
    parfor i = 1: NP
       

        [Fit(i) gy(i,:)]= func5( f(i,:),a,b,T0,afa,Gy_sum,r,k,i) ;

    
    end
    maxFit = max (Fit);%最大值
    minFit = min (Fit) ;%最小值
    rr = find (Fit==maxFit ) ;
    fBest = f (rr ( 1,1), : ) ;%历代最优个体
    frr=rr(1,1);
    GY=gy(rr(1,1),:);
    Fit = (Fit - minFit)/ (maxFit - minFit);
    %归一化适应度值%%%%%%%%%%%%%%基于轮盘赌的复制操作%%%%%%%%%%%%%
    sum_Fit = sum (Fit) ;
    fitvalue = Fit./sum_Fit;
    fitvalue = cumsum ( fitvalue) ;
    ms = sort (rand (NP,1 ) );
    fiti = 1;
    newi = 1;
    while newi <= NP
        if(ms ( newi) ) <fitvalue ( fiti)
            nf(newi, :) =f (fiti, : ) ;
            newi = newi + 1;
        else
            fiti = fiti +1;
        end
    end
    %%%%%%%%%%%%%%%基于概率的交叉操作%%%%%%%%%%%%%
    for i = 1:2:NP
        p = rand;
        if p < Pc
            q= randi ( [0,1],1,L);
            for j = 1:L
                if q(j)==1
                    temp = nf (i + 1,j );nf(i + 1,j) = nf (i,j);nf ( i,j)= temp;
                end
            end
        end
    end
    %%%%%%%%%%%%%基于概率的变异操作%%%%%%%%%%%%%%
    for m = 1:NP
        parfor n = 1:L
            r = rand ( 1,1) ;
            if r < Pm
                nf (m, n) = ~nf (m, n) ;
            end
        end
    end
    f = nf;
    f (1,: ) = fBest;
    %保留最优个体在新种群中
    trace (h) = maxFit;
    %历代最优适应度
end
fBest
%最优个体
figure;
plot (trace)
xlabel ('迭代次数')
ylabel('目标函数值')
title( '适应度进化曲线' )

```
```[matlab]
%%%%%%%%%%%%%适应度函数%%%%%%%%%%%%%
function [result,gy] = func5 (f,a,b,T0,afa,Gy_sum,r,k,i)
Gy=zeros(1,21);
day_num=sum(f(1:21));
tspan1=[0:0.0001:0.0039];
tspan2=[0.004:0.0001:0.9999];
tspan3=[0:0.0001:0.9999];
sum_H=0;
for j=1:21        %转化为10进制
    H(j)=f(j*3-2+21)*4;
    H(j)=f(j*3-1+21)*2+H(j);
    H(j)=f(j*3+21)+H(j)+1;
end
for j=1:21
    if f(j)==1
        sum_H=sum_H+H(j);
    end
end

if sum(f(1:21))<7 || sum(f(1:21))>18
    parfor j=1:21
    Gy(j)=Gy_sum/sum(f(1:21));
    end
else
    x=0;%标记变量
    while x==0
        x=1;
        
        for j=1:21
            if f(j)==1
                Gy(j)=H(j)/sum_H*Gy_sum;
                if Gy(j)<2.5
                    H(j)=H(j)+0.5;
                    x=0;
                elseif Gy(j)>6.5
                    H(j)=H(j)-0.5;
                    x=0;
                    
                end
            end
        end
        
        sum_H=0;
        for j=1:21
            if f(j)==1
                sum_H=sum_H+H(j);
            end
        end
    end
end

% f(1:21)
% H
% Gy

 p=0;%判断是否运行过
for j=1:21
     c(1)=a*Gy(j)+b*Gy(j)^2;
   
    if f(j)==1
        if p==0
            [t,T1]=ode45(@(t,T) r.*T.*(k-T)./k  +   c(1).*T ,tspan1,T0);
            [t,T2]=ode45(@(t,T) r.*T.*(k-T)./k  ,tspan2,T1(40));
            T=[T1' T2'];
            p=1;
        else
            
            
             if p==2
                [t,T1]=ode45(@(t,T) r.*T.*(k-T)./k  +   c(1).*T ,tspan1,T2(10000));
                [t,T2]=ode45(@(t,T) r.*T.*(k-T)./k  ,tspan2,T1(40));
                T=[T T1' T2'];
                p=1;
            else
                [t,T1]=ode45(@(t,T) r.*T.*(k-T)./k +   c(1).*T ,tspan1,T2(9960));
                [t,T2]=ode45(@(t,T) r.*T.*(k-T)./k  ,tspan2,T1(40));
                T=[T T1' T2'];
                p=1;
            end
            
        end
    else
        if p==0
            
            [t,T2]=ode45(@(t,T) r.*T.*(k-T)./k  ,tspan3,T0);
            T=T2';
            p=2;
        else
            if p==2
                [t,T2]=ode45(@(t,T) r.*T.*(k-T)./k  ,tspan3,T2(10000));
                T=[T  T2'];
                p=2;
            else
                [t,T2]=ode45(@(t,T) r.*T.*(k-T)./k  ,tspan3,T2(9960));
                T=[T  T2'];
                p=2;
            end
        end
    end
end

fit=T0-T(210000);

for i=1:21
    if T(i*10000)>T0
        fit=fit-afa;
    end
end
        
        
gy=Gy;

if day_num<7 || day_num>18
    result=fit-afa;
    
elseif f(1)==0||f(21)==0
    result=fit-20;
    
else
    result=fit;
    
end

end

```

### 效果
{% fb_img https://cdn.jsdelivr.net/gh/che10086/CDN@master/image/blog_image/数模/遗传算法/model3_1.png 2 %}
###程序下载
[Download](https://cdn.jsdelivr.net/gh/che10086/CDN@master/资源/数模.rar)





---
title: 广度优先遍历寻找所有路径
categories:  技术
avatar: /image/33cat1.jpg
description: 数据结构实验课第9次作业
authorAbout: 落叶飘零，又是一个春夏秋冬
photos: https://cdn.jsdelivr.net/gh/che10086/CDN@master/image/cover/img3.jpg
covers:  https://cdn.jsdelivr.net/gh/che10086/CDN@master/image/blog_image/数据结构/1.jpg
---


## Quick Start

### 简述

利用（实验指导书186页实验8.2）的代码，用广度优先遍历的方法，找出顶点4到顶点1的路径并输出该路径。网上大部分教程都是用递归加深度优先遍历来做的，而这次题目要求用广度遍历。
<img src="https://cdn.jsdelivr.net/gh/che10086/CDN@master/image/blog_image/数据结构/1.jpg" width=400 height=300 />

### 程序思想
程序简述图：
{% fb_img https://cdn.jsdelivr.net/gh/che10086/CDN@master/image/blog_image/数据结构/2.jpg 1 %}
附加题根据广度优先遍历的思想，一层一层地遍历符合条件的节点。路径结束条件是：1.找到与开头相同节点2.找到这个路径节点走过的节点3.找到目标节点。同时用两个栈数组分别储存前一层的节点的路径和后一层的节点的路径。程序思想是：遍历前一层节点，通过前一层节点拓展后一层节点，并把前一层节点路径复制到后一层节点中，用while周而复始。结束的条件是：后一层的栈为空。

### 主要函数

```c++
void PathAll(AdjGraph *&G,int u ,int v)  //G为图，u为起始点，v为终点
{
    //初始化变量和栈——————————————————————————————————
    int i, j;//作为通用计数变量
    int a, b;//分别为A栈下标，B栈下标
int g;//分别为A栈总数
int h;//为路径数
    int k;//作为广度层数变量
    int e;//作为中间变量
    int patha[10][10], pathb[10][10];//走过的路径
    ArcNode* p;//初始化图
    LinkStNode* A[10],*B[10],*C[10];//A作为输入栈，B为输出栈,C作为中转栈
    for (i = 0; i < 10; i++) {
        InitStack(A[i]); 
        InitStack(B[i]); 
        InitStack(C[i]);;
    }
    //赋初值：变量、path和栈A、B、C——————————————————————————
    a = 0;
    b = 0;
    k = 1;
    g = 1;
    h = 0;
    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) { 
            patha[i][j] = 0; 
            pathb[i][j] = 0;
        }
    }
    Push(A[a], u);
    //正式处理———————————————————————————————————————
    while (g != 0) {
        b = 0;
        
        for (a = 0; a < g; a++) {
            Pop(A[a], e);
            p = G->adjlist[e].firstarc;
            Push(A[a], e);
            
            while (p != NULL) {
                
                if (p->adjvex == v) {       //当找到v时直接输出
                    h++;
                    printf("\n路径%d：",h);
                    while (!StackEmpty(A[a])) {
                        Pop(A[a], e);
                        Push(C[a], e);
                    }
                    while (!StackEmpty(C[a])) {
                        Pop(C[a], e);
                        printf("%d ", e);
                    }
                    printf("%d ", p->adjvex == v);
                }
                else if (p->adjvex != u && patha[a][p->adjvex] != 1) {  //符合进B栈的条件
                    //将A赋值给B————————————————————
                    while (!StackEmpty(A[a])){
                         Pop(A[a],e);
                         Push(C[a], e);
                    }
                    while (!StackEmpty(C[a])) {
                        Pop(C[a], e);
                        Push(B[b], e);
                        Push(A[a], e);
                    }
                    //————————————————————————————————
                    Push(B[b], p->adjvex);
                    
                    for (i = 0; i < 10; i++) {
                        pathb[b][i] = patha[a][i];//将patha赋值给pathb
                    }
                    pathb[b][p->adjvex] = 1;

                    b++;//将路径数增加
                }
                p = p->nextarc;
            }
            
        }
        g = b;

        for (i = 0; i < b; i++) {
            for (j = 0; j < 10; j++) {
                patha[i][j] = pathb[i][j];
            
            }
        }

        //清空A栈
        for (i = 0; i < 10; i++) {
            while (!StackEmpty(A[i]))
            {
                Pop(A[i], e);
               
            }
        
        }
        //赋值B-》A
        for (i = 0; i < 10; i++) {
            while (!StackEmpty(B[i]))
            {
                Pop(B[i], e);
                Push(C[i], e);
            }
            while (!StackEmpty(C[i]))
            {
                Pop(C[i], e);
                Push(A[i], e);
            }
        }
        //清空B栈
        for (i = 0; i < 10; i++) {
            while (!StackEmpty (B[i]))
            {
                Pop(B[i], e);
            }}
        k++;
    }
}

```
### 下载程序
[Download](https://cdn.jsdelivr.net/gh/che10086/CDN@master/资源/fujiati9.rar)

### 小结
在找路径这方面，广度优先遍历比深度优先遍历复杂很多，不论是空间复杂度还是时间复杂度。找路径还是用深度遍历递归算法比较好，除非要应对课程作业。



